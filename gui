-- Load the MetaGUI library
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/zxcreload/metagui/refs/heads/main/library"))()

-- Initialize anti-cheat bypass
for _, v in pairs(getgc(true)) do
    if type(v) == "table" then
        setreadonly(v, false)
        local indexInstance = rawget(v, "indexInstance")
        if type(indexInstance) == "table" and indexInstance[1] == "kick" then
            setreadonly(indexInstance, false)
            rawset(v, "Table", {"kick", function() coroutine.yield() end})
            warn("\n---[ INFO ]---\nBypassed Adonis Anti-Cheat/Anti-Exploit.\nMethod: Prevented Script Table Communication With Server.")
            break
        end
    end
end

-- Create a window
local Window = Library:Window({
    Name = "FULL.SKID"
})

-- Create pages (tabs)
local CombatPage = Window:Page({
    Name = "Combat"
})

local MovementPage = Window:Page({
    Name = "Movement"
})

local VisualsPage = Window:Page({
    Name = "Visuals"
})

local MiscPage = Window:Page({
    Name = "Misc"
})

local ConfigPage = Window:Page({
    Name = "Config"
})

-- Create Config sections
local UISection = ConfigPage:Section({
    Name = "Interface",
    Side = "left"
})

-- GUI Toggle keybind
UISection:Keybind({
    Name = "Toggle GUI",
    Default = Enum.KeyCode.Insert,
    Flag = "ToggleGUI",
    Mode = "Toggle",  -- Явно указываем режим Toggle
    Callback = function(value)
        -- Прямой вызов SetOpen
        Library:SetOpen(value)
    end
})

-- Accent color picker
UISection:Colorpicker({
    Name = "Accent Color",
    Default = Color3.fromRGB(85, 170, 255),
    Flag = "AccentColor",
    Callback = function(Color)
        Library:ChangeAccent(Color)
    end
})

-- Setup Config Manager in the right section
local PresetsSection = ConfigPage:Section({
    Name = "Presets",
    Side = "right"
})

-- Initialize the built-in config manager
Library:SetupConfigManager(ConfigPage)

-- Load all available configurations
Library:LoadAllConfigs()

-- Создаем ватермарк
local Watermark = Library:Watermark({
    Name = "FULL.SKID"
})

-- Создаем секцию для индикатора в Config
local InfoSection = ConfigPage:Section({
    Name = "Display",
    Side = "right"
})

-- Создаем секцию для StaffList в Config
local StaffSection = ConfigPage:Section({
    Name = "Staff",
    Side = "left"
})

-- Создаем индикатор через библиотеку
local Indicator = Library:Indicator({
    Name = "FULL.SKID" -- Индикатор можно перемещать мышкой
})

-- Создаем StaffList
local StaffList = Library:StaffList({
    Name = "Staff List" -- Список персонала можно перемещать мышкой
})

-- Устанавливаем начальную позицию индикатора по центру экрана
Indicator:SetPosition("top")

-- Список вариантов информации для индикатора
local IndicatorOptions = {
    "coordinates",
    "state",
    "ping",
    "speed"
}

-- Toggle для включения/выключения индикатора
InfoSection:Toggle({
    Name = "Indicator",
    Default = false,
    Flag = "IndicatorEnabled",
    Callback = function(Value)
        -- Показываем/скрываем индикатор
        Indicator:SetVisible(Value)
        
        -- При включении обновляем отображаемые элементы
        if Value then
            UpdateIndicatorElements()
        end
    end
})

-- Выбор информации для индикатора
InfoSection:List({
    Name = "Info Elements",
    Options = IndicatorOptions,
    Default = {},
    Max = #IndicatorOptions,
    Flag = "IndicatorInfo",
    Callback = function(Selected)
        if Library.Flags["IndicatorEnabled"] then
            UpdateIndicatorElements()
        end
    end
})

-- Toggle для включения/выключения StaffList
StaffSection:Toggle({
    Name = "Staff List",
    Default = false,
    Flag = "StaffListEnabled",
    Callback = function(Value)
        -- Показываем/скрываем StaffList
        StaffList:SetVisible(Value)
    end
})

-- Функция для получения FPS
local function GetFPS()
    return math.floor(1/game:GetService("RunService").RenderStepped:Wait())
end

-- Список вариантов информации для ватермарка
local WatermarkOptions = {
    "client",
    "username",
    "fps",
    "time",
    "date"
}

-- Переменные для отслеживания движения
local lastPosition = nil
local isMoving = false
local movementThreshold = 0.05 -- Порог для определения движения

-- Функция для получения координат персонажа
local function GetCoordinates()
    local player = game:GetService("Players").LocalPlayer
    if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local pos = player.Character.HumanoidRootPart.Position
        return string.format("%d,%d,%d", math.floor(pos.X), math.floor(pos.Y), math.floor(pos.Z))
    end
    return "N/A"
end

-- Функция для определения скорости персонажа
local function GetSpeed()
    local player = game:GetService("Players").LocalPlayer
    if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local humanoidRootPart = player.Character.HumanoidRootPart
        -- Вычисляем только горизонтальную скорость (без учета вертикали)
        local velocity = humanoidRootPart.Velocity
        local horizSpeed = math.sqrt(velocity.X^2 + velocity.Z^2)
        return string.format("%d s/s", math.floor(horizSpeed))
    end
    return "N/A"
end

-- Функция для получения состояния персонажа (в воздухе или на земле)
local function GetState()
    local player = game:GetService("Players").LocalPlayer
    if player and player.Character then
        local humanoid = player.Character:FindFirstChild("Humanoid")
        
        if humanoid then
            -- Проверяем, находится ли персонаж на земле
            if humanoid.FloorMaterial == Enum.Material.Air then
                return "Air"
                else
                return "Ground"
            end
        end
    end
    return "N/A"
end

-- Функция для получения пинга
local function GetPing()
    local stats = game:GetService("Stats")
    local ping = math.floor(stats.Network.ServerStatsItem["Data Ping"]:GetValue())
    return ping .. "ms"
end

-- Функция для форматирования времени
local function GetTimeFormatted()
    local time = os.date("*t")
    return string.format("%02d:%02d:%02d", time.hour, time.min, time.sec)
end

-- Функция для форматирования даты
local function GetDateFormatted()
    local date = os.date("*t")
    return string.format("%02d/%02d/%d", date.day, date.month, date.year)
end

-- Функция для обновления содержимого индикатора на основе выбранных опций
function UpdateIndicatorElements()
    -- Получаем выбранные опции
    local selectedOptions = Library.Flags["IndicatorInfo"] or {}
    
    -- Если список опций пуст, очищаем индикатор и завершаем функцию
    if #selectedOptions == 0 then
    Indicator:ClearAll()
        return
    end
    
    -- Создаем таблицу для быстрой проверки
    local optionsMap = {}
    for _, option in ipairs(selectedOptions) do
        optionsMap[option] = true
    end
    
    -- Находим элементы, которые нужно удалить (те, которые есть, но не выбраны)
    for _, key in ipairs({"coordinates", "state", "ping", "speed"}) do
        if Indicator:HasElement(key) and not optionsMap[key] then
            Indicator:RemoveElement(key)
        end
    end
    
    -- Добавляем или обновляем выбранные элементы
    if optionsMap["coordinates"] then
            Indicator:NewValue({
                Key = "coordinates",
                Name = "Coords:",
                Value = GetCoordinates()
            })
    end
    
    if optionsMap["state"] then
            Indicator:NewValue({
                Key = "state",
            Name = "Position:",
                Value = GetState()
            })
    end
    
    if optionsMap["ping"] then
            Indicator:NewValue({
                Key = "ping",
                Name = "Ping:",
                Value = GetPing()
            })
    end
    
    if optionsMap["speed"] then
            Indicator:NewValue({
                Key = "speed",
                Name = "Speed:",
                Value = GetSpeed()
            })
    end
end

-- Функция для периодического обновления значений индикатора
spawn(function()
    while wait(0.1) do
        if Library.Flags["IndicatorEnabled"] then
            -- Получаем выбранные опции
            local selectedOptions = Library.Flags["IndicatorInfo"] or {}
            
            -- Если нет выбранных опций, пропускаем
            if #selectedOptions == 0 then
                continue
            end
            
            -- Создаем таблицу для быстрой проверки
            local optionsMap = {}
            for _, option in ipairs(selectedOptions) do
                optionsMap[option] = true
            end
            
            -- Безопасно обновляем каждое значение, только если оно выбрано и существует
            if optionsMap["coordinates"] and Indicator:HasElement("coordinates") then
                Indicator:SafeUpdateValue("coordinates", GetCoordinates())
            end
            
            if optionsMap["state"] and Indicator:HasElement("state") then
                Indicator:SafeUpdateValue("state", GetState())
            end
            
            if optionsMap["ping"] and Indicator:HasElement("ping") then
                Indicator:SafeUpdateValue("ping", GetPing())
            end
            
            if optionsMap["speed"] and Indicator:HasElement("speed") then
                Indicator:SafeUpdateValue("speed", GetSpeed())
            end
        end
    end
end)

-- Функция для обновления текста ватермарка
local function UpdateWatermark()
    -- Получаем выбранные опции
    local selectedOptions = Library.Flags["WatermarkInfo"] or {}
    if #selectedOptions == 0 then
        Watermark:UpdateText("Select watermark info ")
        return
    end
    
    -- Создаем таблицу для компонентов в правильном порядке
    local components = {}
    
    -- Проверяем каждую опцию в порядке, указанном пользователем
    for _, option in ipairs(WatermarkOptions) do
        if table.find(selectedOptions, option) then
            if option == "client" then
                table.insert(components, "FULL.SKID")
            elseif option == "username" then
                local player = game:GetService("Players").LocalPlayer
                table.insert(components, player and player.Name or "User")
            elseif option == "fps" then
                table.insert(components, "FPS: " .. GetFPS())
            elseif option == "time" then
                table.insert(components, GetTimeFormatted())
            elseif option == "date" then
                table.insert(components, GetDateFormatted())
            end
        end
    end
    
    -- Объединяем все компоненты в одну строку с разделителем и добавляем отступ в конце
    Watermark:UpdateText(table.concat(components, " | ") .. " ")
end

-- Функция для установки позиции ватермарки
local function SetWatermarkPosition(position)
    if Watermark then
        -- Просто вызываем метод SetPosition из библиотеки
        Watermark:SetPosition(position)
    end
end

-- Добавляем управление ватермарком в секцию Presets
PresetsSection:Toggle({
    Name = "Watermark",
    Default = false,
    Flag = "WatermarkEnabled",
    Callback = function(Value)
        if Watermark then
            Watermark:SetVisible(Value)
            -- При включении сразу обновляем текст
            if Value then
                UpdateWatermark()
                -- Применяем текущую выбранную позицию
                SetWatermarkPosition(Library.Flags["WatermarkPosition"] or "left")
            end
        end
    end
})

-- Список вариантов позиций для ватермарка
local PositionOptions = {
    "left",
    "right",
    "top"
}

-- Добавляем выбор позиции для ватермарка
PresetsSection:List({
    Name = "WM Position",
    Options = PositionOptions,
    Default = "left",
    Flag = "WatermarkPosition",
    Callback = function(Selected)
        if Library.Flags["WatermarkEnabled"] and Watermark then
            -- Используем новую функцию для позиционирования
            SetWatermarkPosition(Selected)
        end
    end
})

-- Создаем мультибокс для выбора информации ватермарка
PresetsSection:List({
    Name = "WM Content",
    Options = WatermarkOptions,
    Default = {},
    Max = #WatermarkOptions, -- Разрешаем выбрать все опции
    Flag = "WatermarkInfo",
    Callback = function(Selected)
        UpdateWatermark()
    end
})

-- Функция для периодического обновления ватермарка
spawn(function()
    while wait(1) do
        if Library.Flags["WatermarkEnabled"] and Watermark then
            UpdateWatermark()
        end
    end
end)

-- Создаем секцию для Keybinds List в Config
local KeybindsSection = ConfigPage:Section({
    Name = "Keybinds",
    Side = "left"
})

-- Создаем KeybindsList
local KeybindsList = Library:KeybindsList({
    Name = "Keybinds List",
    Flags = {} -- Заполним после выбора
})

-- Устанавливаем начальную позицию в правом верху экрана
KeybindsList:SetPosition("right")

-- Список доступных кейбиндов (флаги и названия)
local AvailableKeybinds = {
    {Flag = "ToggleGUI", Name = "Toggle GUI"},
    {Flag = "RizzTalkKey", Name = "Rizz Talk"},
    {Flag = "AdTalkKey", Name = "Ad Talk"}
    -- Добавь сюда свои кейбинды, если появятся новые
}

local KeybindFlags = {}
local KeybindNames = {}
for _, v in ipairs(AvailableKeybinds) do
    table.insert(KeybindFlags, v.Flag)
    table.insert(KeybindNames, v.Name)
end

-- Toggle для включения/выключения Keybinds List
KeybindsSection:Toggle({
    Name = "Keybinds List",
    Default = false,
    Flag = "KeybindsListEnabled",
    Callback = function(Value)
        KeybindsList:SetVisible(Value)
        
        -- При включении обновляем отображаемые элементы
        if Value then
            local selectedFlags = {}
            local selectedOptions = Library.Flags["KeybindsListFlags"] or {}
            
            for i, name in ipairs(KeybindNames) do
                if table.find(selectedOptions, name) then
                    table.insert(selectedFlags, KeybindFlags[i])
                end
            end
            
            KeybindsList:SetFlags(selectedFlags)
        end
    end
})

-- Мультибокс для выбора отображаемых кейбиндов
KeybindsSection:List({
    Name = "Show Keybinds",
    Options = KeybindNames,
    Default = {KeybindNames[1]}, -- По умолчанию выбираем первый кейбинд
    Max = #KeybindNames,
    Flag = "KeybindsListFlags",
    Callback = function(selected)
        -- Преобразуем выбранные имена в флаги
        local selectedFlags = {}
        for i, name in ipairs(KeybindNames) do
            if table.find(selected, name) then
                table.insert(selectedFlags, KeybindFlags[i])
            end
        end
        KeybindsList:SetFlags(selectedFlags)
    end
})

-- Create a notification to show the UI is loaded
Library:Notification("UI loaded successfully", 3)

-- Manually add InputBegan event for Insert key as backup toggle
game:GetService("UserInputService").InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.Insert then
        Library:SetOpen(not Library.Open)
    end
end)

-- Create Misc sections
local FeaturesSection = MiscPage:Section({
    Name = "General",
    Side = "left"
})

-- Create Player Features section
local PlayerFeaturesSection = MiscPage:Section({
    Name = "Player",
    Side = "left"
})

-- Create Movement Features section
local MovementFeaturesSection = MiscPage:Section({
    Name = "Movement",
    Side = "right"
})

-- Initialize Noclip
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local NoclipEnabled = false
local originalCollisionStates = {}

-- Function to store original collision states
local function SaveOriginalStates(character)
    originalCollisionStates = {}
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            originalCollisionStates[part] = part.CanCollide
        end
    end
end

-- Function to restore original collision states
local function RestoreOriginalStates(character)
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") and originalCollisionStates[part] ~= nil then
            part.CanCollide = originalCollisionStates[part]
        end
    end
end

local function UpdateNoclip()
    if not LocalPlayer.Character then return end
    
    if NoclipEnabled then
        for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    else
        RestoreOriginalStates(LocalPlayer.Character)
    end
end

-- Handle character respawning
LocalPlayer.CharacterAdded:Connect(function(char)
    wait(0.5) -- Wait for character to fully load
    SaveOriginalStates(char)
end)

-- Save states for initial character
if LocalPlayer.Character then
    SaveOriginalStates(LocalPlayer.Character)
end

-- Create Noclip toggle
MovementFeaturesSection:Toggle({
    Name = "Noclip",
    Default = false,
    Flag = "NoclipEnabled",
    Callback = function(Value)
        NoclipEnabled = Value
        if Value then
            if LocalPlayer.Character then
                SaveOriginalStates(LocalPlayer.Character)
            end
            Library:Notification("Noclip Enabled", 1)
        else
            if LocalPlayer.Character then
                RestoreOriginalStates(LocalPlayer.Character)
            end
            Library:Notification("Noclip Disabled", 1)
        end
    end
})

-- Connect Noclip update to RenderStepped
RunService.RenderStepped:Connect(UpdateNoclip)

-- Initialize Desync variables and functions
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local LocalPlayer = Players.LocalPlayer
local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local playerName = LocalPlayer.Name

-- Desync settings and variables
local Settings = {
    AntiAim = {
        FFlagDesync = {
            Enabled = true,
            Amount = 20,
            SetNew = true,
            SetNewAmount = 60,
            FFlags = {
                ["S2PhysicsSenderRate"] = true,
                ["PhysicsSenderMaxBandwidthBps"] = false,
                ["DataSenderMaxJoinBandwidthBps"] = false
            }
        }
    }
}

local state = false
local defaultFFlagValues = {}
local currentClone = nil

local Script = {}
Script.Functions = {}

-- Save default FFlag values
Script.Functions.SaveDefaultFFlags = function()
    for FFlag, _ in pairs(Settings.AntiAim.FFlagDesync.FFlags) do
        defaultFFlagValues[FFlag] = getfflag(FFlag) or "0"
    end
end

-- Apply/reset desync
Script.Functions.FFlagDesync = function()
    if not Settings.AntiAim.FFlagDesync.Enabled then return end

    for FFlag, _ in pairs(Settings.AntiAim.FFlagDesync.FFlags) do
        if state then
            local Value = Settings.AntiAim.FFlagDesync.Amount
            setfflag(FFlag, tostring(Value))
            RunService.RenderStepped:Wait()
            if Settings.AntiAim.FFlagDesync.SetNew then
                setfflag(FFlag, tostring(Settings.AntiAim.FFlagDesync.SetNewAmount))
            end
        else
            if defaultFFlagValues[FFlag] then
                setfflag(FFlag, defaultFFlagValues[FFlag])
            end
        end
    end
end

-- Reset clone and desync
local function resetClone()
    if currentClone then
        currentClone:Destroy()
        currentClone = nil
    end
    state = false
    Script.Functions.FFlagDesync()
end

-- Create visual clone
local function createVisualClone()
    if currentClone then
        currentClone:Destroy()
    end
    
    local cloneModel = Instance.new("Model")
    cloneModel.Name = "0x78"
    local partMap = {}
    local originalHRP = character:WaitForChild("HumanoidRootPart")
    local cloneHRP = nil

    local function disableCollision(obj)
        for _, part in pairs(obj:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
                part.Anchored = true
                part.CanTouch = false
                part.Massless = true
            end
        end
    end

    -- Copy body parts excluding tools
    for _, child in pairs(character:GetDescendants()) do
        if child:IsA("BasePart") and not child.Parent:IsA("Accessory") and not child:IsA("Tool") and not child.Parent:IsA("Tool") then
            local clonePart = child:Clone()
            for _, descendant in pairs(clonePart:GetDescendants()) do
                if descendant:IsA("Motor6D") or descendant:IsA("Weld") then
                    descendant:Destroy()
                end
            end
            if clonePart.Name == "Head" and clonePart:IsA("MeshPart") then
                clonePart.TextureID = ""
            end
            clonePart.CanCollide = false
            clonePart.Anchored = true
            clonePart.CanTouch = false
            clonePart.Massless = true
            clonePart.Parent = cloneModel
            partMap[clonePart] = child
            if clonePart.Name == "HumanoidRootPart" then
                cloneHRP = clonePart
            end
        elseif child:IsA("Accessory") then
            local cloneAccessory = child:Clone()
            for _, accessoryPart in pairs(cloneAccessory:GetDescendants()) do
                if accessoryPart:IsA("Motor6D") or accessoryPart:IsA("Weld") or accessoryPart:IsA("Attachment") then
                    accessoryPart:Destroy()
                end
                if accessoryPart:IsA("BasePart") then
                    accessoryPart.CanCollide = false
                    accessoryPart.Anchored = true
                    accessoryPart.CanTouch = false
                    accessoryPart.Massless = true
                    local originalHandle = child:FindFirstChildWhichIsA("BasePart")
                    if originalHandle then
                        partMap[accessoryPart] = originalHandle
                    end
                end
            end
            cloneAccessory.Parent = cloneModel
        end
    end

    -- Copy clothing
    local playerPath = workspace:WaitForChild("Players"):WaitForChild(playerName)
    if playerPath:FindFirstChild("Pants") then
        local pantsClone = playerPath.Pants:Clone()
        pantsClone.Parent = cloneModel
    end
    if playerPath:FindFirstChild("Shirt") then
        local shirtClone = playerPath.Shirt:Clone()
        shirtClone.Parent = cloneModel
    end

    -- Final collision check
    disableCollision(cloneModel)
    cloneModel.PrimaryPart = cloneHRP
    cloneModel.Parent = workspace
    currentClone = cloneModel

    -- Freeze clone in current state
    for clonedPart, originalPart in pairs(partMap) do
        clonedPart.CFrame = originalPart.CFrame
    end

    -- Monitor clone changes
    cloneModel.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("BasePart") then
            descendant.CanCollide = false
            descendant.Anchored = true
            descendant.CanTouch = false
            descendant.Massless = true
        end
    end)
end

-- Character death handler
local function onCharacterDeath()
    resetClone()
end

-- Character respawn handler
local function onCharacterAdded(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    humanoid.Died:Connect(onCharacterDeath)
end

-- Subscribe to death and respawn events
humanoid.Died:Connect(onCharacterDeath)
LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

-- Create Desync toggle and keybind
local DesyncToggle = PlayerFeaturesSection:Toggle({
    Name = "Desync",
    Default = false,
    Flag = "DesyncEnabled",
    Callback = function(Value)
        if not Value then
            -- When toggle is disabled, force disable desync
            state = false
            resetClone()
        end
    end
})



-- Create Desync keybind
PlayerFeaturesSection:Keybind({
    Name = "DesyncKeybind",
    Flag = "DesyncKey",
    Mode = "Hold", -- Changed to Hold mode
    Callback = function(keyState)
        -- Only process keybind if desync is enabled via toggle
        if not Library.Flags["DesyncEnabled"] then return end
        
        -- Update state based on key state
        if keyState then
            if not state then -- Only create clone if not already created
                state = true
                createVisualClone()
                Script.Functions.FFlagDesync()
                Library:Notification("Desync Enabled", 1)
            end
        else
            if state then -- Only reset if currently active
                resetClone()
                Library:Notification("Desync Disabled", 1)
            end
        end
    end
})

-- Save initial FFlags
Script.Functions.SaveDefaultFFlags()

-- Initialize last blink time
local lastBlinkTime = os.clock()

-- Continue heartbeat monitoring
RunService.Heartbeat:Connect(function()
    if state and humanoid.Health > 0 then
        Script.Functions.FFlagDesync()


    elseif state and humanoid.Health <= 0 then
        resetClone()
    end
end)

-- Add desync to available keybinds list
table.insert(AvailableKeybinds, {Flag = "DesyncKey", Name = "Desync"})
-- Update KeybindFlags and KeybindNames
KeybindFlags = {}
KeybindNames = {}
for _, v in ipairs(AvailableKeybinds) do
    table.insert(KeybindFlags, v.Flag)
    table.insert(KeybindNames, v.Name)
end

-- Initialize Anti AFK variables
local antiAfkConnection = nil

-- Anti AFK Toggle
FeaturesSection:Toggle({
    Name = "AntiAFK",
    Default = false,
    Flag = "AntiAFKEnabled",
    Callback = function(value)
        local VirtualUser = game:GetService("VirtualUser")
        local LocalPlayer = game:GetService("Players").LocalPlayer

        if value then -- Enable Anti AFK
            if LocalPlayer and antiAfkConnection == nil then
                antiAfkConnection = LocalPlayer.Idled:Connect(function()
                    VirtualUser:CaptureController()
                    VirtualUser:ClickButton2(Vector2.new())
                end)
            end
        else -- Disable Anti AFK
            if antiAfkConnection ~= nil then
                antiAfkConnection:Disconnect()
                antiAfkConnection = nil
            end
        end
    end
})

-- Initialize Destroy Cheaters variables
local NewCFrame = CFrame.new
local LocalFinobe = game:GetService("Players").LocalPlayer
local Runfinobe = game:GetService("RunService")
local destroyCheatersEnabled = false
local finobe2 = nil

-- Destroy Cheaters Toggle
FeaturesSection:Toggle({
    Name = "DestroyCheaters",
    Default = false,
    Flag = "DestroyCheatersEnabled",
    Callback = function(value)
        if not value and LocalFinobe.Character and LocalFinobe.Character:FindFirstChild("HumanoidRootPart") and finobe2 then
            -- При выключении возвращаем в исходную позицию перед отключением
            LocalFinobe.Character.HumanoidRootPart.CFrame = finobe2
            finobe2 = nil
        end
        
        destroyCheatersEnabled = value
        getgenv().Finobe1 = value
        
        if value then
            Library:Notification("Destroy Cheaters Enabled", 1)
        else
            Library:Notification("Destroy Cheaters Disabled", 1)
        end
    end
})

-- Create the connection
Runfinobe.Heartbeat:Connect(function()
    if LocalFinobe.Character and destroyCheatersEnabled then
        local FinobeChar = LocalFinobe.Character:FindFirstChild("HumanoidRootPart")
        if FinobeChar then
            if getgenv().Finobe1 then
                finobe2 = FinobeChar.CFrame
                FinobeChar.CFrame = FinobeChar.CFrame * NewCFrame(9e9, 0/0, math.huge)
                Runfinobe.RenderStepped:Wait()
                if destroyCheatersEnabled then
                    FinobeChar.CFrame = finobe2
                end
            end
        end
    end
end)

local hook
hook = hookmetamethod(game, "__index", newcclosure(function(self, key)
    if not checkcaller() then
        if key == "CFrame" and getgenv().Finobe1 and LocalFinobe.Character and LocalFinobe.Character:FindFirstChild("HumanoidRootPart") and LocalFinobe.Character:FindFirstChild("Humanoid") and LocalFinobe.Character:FindFirstChild("Humanoid").Health > 0 then
            if self == LocalFinobe.Character.HumanoidRootPart and finobe2 ~= nil then
                return finobe2
            end
        end
    end
    return hook(self, key)
end))

-- Wait for game to load (auto-execute support)
if not game:IsLoaded() then 
    game.Loaded:Wait()
end

-- Initialize No Jump Cooldown variables
local IsA = game.IsA
local newindex = nil

-- Add No Jump Cooldown Toggle to Movement Features section
MovementFeaturesSection:Toggle({
    Name = "NoJumpCooldown",
    Default = false,
    Flag = "NoJumpCooldownEnabled",
    Callback = function(value)
        if value then
            -- Setup the hook when enabled
            if not newindex then
                newindex = hookmetamethod(game, "__newindex", function(self, Index, Value)
                    if not checkcaller() and IsA(self, "Humanoid") and Index == "JumpPower" then 
                        return
                    end
                    return newindex(self, Index, Value)
                end)
            end
            Library:Notification("No Jump Cooldown Enabled", 1)
        else
            Library:Notification("No Jump Cooldown Disabled", 1)
        end
    end
})

-- Initialize Movement Features variables
local savedSeats = {}
local antiSitEnabled = false

-- Create Anti Sit toggle
MovementFeaturesSection:Toggle({
    Name = "AntiSit",
    Default = false,
    Flag = "AntiSitEnabled",
    Callback = function(value)
        antiSitEnabled = value
        
        if value then
            -- Store and remove seats
            savedSeats = {}
            for _, object in pairs(game:GetDescendants()) do
                if object:IsA("Seat") or object:IsA("VehicleSeat") then
                    table.insert(savedSeats, {
                        object = object,
                        parent = object.Parent,
                        properties = {
                            CFrame = object.CFrame,
                            Anchored = object.Anchored,
                            CanCollide = object.CanCollide
                        }
                    })
                    object.Parent = nil -- Скрываем объект вместо удаления
                end
            end
            Library:Notification("Anti Sit Enabled", 1)
        else
            -- Restore seats
            for _, seatData in ipairs(savedSeats) do
                if seatData.object and seatData.parent then
                    seatData.object.CFrame = seatData.properties.CFrame
                    seatData.object.Anchored = seatData.properties.Anchored
                    seatData.object.CanCollide = seatData.properties.CanCollide
                    seatData.object.Parent = seatData.parent
                end
            end
            savedSeats = {}
            Library:Notification("Anti Sit Disabled", 1)
        end
    end
})

-- Initialize shadows variables
local Lighting = game:GetService("Lighting")
local isShadowsEnabled = true
local originalShadowSettings = {
    GlobalShadows = Lighting.GlobalShadows,
    ShadowSoftness = Lighting.ShadowSoftness
}

-- Function to disable shadows
local function disableShadows()
    if Library.Flags["DisableShadowsEnabled"] then
        Lighting.GlobalShadows = false
        Lighting.ShadowSoftness = 0
    end
end

-- Create DisableShadows toggle
FeaturesSection:Toggle({
    Name = "DisableShadows",
    Default = false,
    Flag = "DisableShadowsEnabled",
    Callback = function(value)
        if value then
            -- Start the shadow disable loop
            spawn(function()
                while Library.Flags["DisableShadowsEnabled"] do
                    disableShadows()
                    wait(5)
                end
            end)
            Library:Notification("Shadows Disabled", 1)
        else
            -- Restore original shadow settings
            Lighting.GlobalShadows = originalShadowSettings.GlobalShadows
            Lighting.ShadowSoftness = originalShadowSettings.ShadowSoftness
            Library:Notification("Shadows Restored", 1)
        end
    end
})

-- Initialize Chat Spy variables and function
local chatSpyEnabled = false
local spyOnMyself = true
local public = false
local publicItalics = true
local privateProperties = {
    Color = Color3.fromRGB(0,255,255); 
    Font = Enum.Font.SourceSansBold;
    TextSize = 18;
}
-- Save original chat settings
local originalChatSettings = {
    ChannelParentFrameVisible = nil,
    BarParentFramePosition = nil
}

-- Create Chat Spy toggle
FeaturesSection:Toggle({
    Name = "ChatSpy",
    Default = false,
    Flag = "ChatSpyEnabled",
    Callback = function(value)
        if value then
            chatSpyEnabled = true
            -- Initialize Chat Spy
            local StarterGui = game:GetService("StarterGui")
            local Players = game:GetService("Players")
            local player = Players.LocalPlayer or Players:GetPropertyChangedSignal("LocalPlayer"):Wait() or Players.LocalPlayer
            local saymsg = game:GetService("ReplicatedStorage"):WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("SayMessageRequest")
            local getmsg = game:GetService("ReplicatedStorage"):WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("OnMessageDoneFiltering")
            local instance = (_G.chatSpyInstance or 0) + 1
            _G.chatSpyInstance = instance

            -- Chat spy function
            local function onChatted(p,msg)
                if not chatSpyEnabled then return end
                if _G.chatSpyInstance == instance then
                    if p==player and msg:lower():sub(1,4)=="/spy" then
                        chatSpyEnabled = not chatSpyEnabled
                        wait(0.3)
                        privateProperties.Text = "{SPY "..(chatSpyEnabled and "EN" or "DIS").."ABLED}"
                        StarterGui:SetCore("ChatMakeSystemMessage",privateProperties)
                    elseif chatSpyEnabled and (spyOnMyself==true or p~=player) then
                        msg = msg:gsub("[\n\r]",''):gsub("\t",' '):gsub("[ ]+",' ')
                        local hidden = true
                        local conn = getmsg.OnClientEvent:Connect(function(packet,channel)
                            if packet.SpeakerUserId==p.UserId and packet.Message==msg:sub(#msg-#packet.Message+1) and (channel=="All" or (channel=="Team" and public==false and Players[packet.FromSpeaker].Team==player.Team)) then
                                hidden = false
                            end
                        end)
                        wait(1)
                        conn:Disconnect()
                        if hidden and chatSpyEnabled then
                            if public then
                                saymsg:FireServer((publicItalics and "/me " or '').."{SPY} [".. p.Name .."]: "..msg,"All")
                            else
                                privateProperties.Text = "{SPY} [".. p.Name .."]: "..msg
                                StarterGui:SetCore("ChatMakeSystemMessage",privateProperties)
                            end
                        end
                    end
                end
            end

            -- Connect chat events
            for _,p in ipairs(Players:GetPlayers()) do
                p.Chatted:Connect(function(msg) onChatted(p,msg) end)
            end
            Players.PlayerAdded:Connect(function(p)
                p.Chatted:Connect(function(msg) onChatted(p,msg) end)
            end)

            -- Setup chat frame and save original settings
            privateProperties.Text = "{SPY ENABLED}"
            StarterGui:SetCore("ChatMakeSystemMessage",privateProperties)
            if not player.PlayerGui:FindFirstChild("Chat") then wait(3) end
            local chatFrame = player.PlayerGui.Chat.Frame
            
            -- Save original settings before modifying
            originalChatSettings.ChannelParentFrameVisible = chatFrame.ChatChannelParentFrame.Visible
            originalChatSettings.BarParentFramePosition = chatFrame.ChatBarParentFrame.Position
            
            -- Apply Chat Spy settings
            chatFrame.ChatChannelParentFrame.Visible = true
            chatFrame.ChatBarParentFrame.Position = chatFrame.ChatChannelParentFrame.Position+UDim2.new(UDim.new(),chatFrame.ChatChannelParentFrame.Size.Y)
            
            Library:Notification("Chat Spy Enabled", 1)
        else
            chatSpyEnabled = false
            privateProperties.Text = "{SPY DISABLED}"
            game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage",privateProperties)
            
            -- Restore original chat settings
            local chatFrame = game:GetService("Players").LocalPlayer.PlayerGui.Chat.Frame
            if originalChatSettings.ChannelParentFrameVisible ~= nil then
                chatFrame.ChatChannelParentFrame.Visible = originalChatSettings.ChannelParentFrameVisible
            end
            if originalChatSettings.BarParentFramePosition ~= nil then
                chatFrame.ChatBarParentFrame.Position = originalChatSettings.BarParentFramePosition
            end
            
            Library:Notification("Chat Spy Disabled", 1)
        end
    end
})

-- Initialize original display names storage
local originalDisplayNames = {}

-- Create OnlyRobloname toggle in Features section
FeaturesSection:Toggle({
    Name = "DefaultName",
    Default = false,
    Flag = "OnlyRoblonameEnabled",
    Callback = function(value)
        if value then
            pcall(function()
                for _, v in pairs(game:GetService("Players"):GetPlayers()) do
                    if v.Character and v.Character:FindFirstChild("Humanoid") then
                        -- Store original display name before changing
                        originalDisplayNames[v.Name] = v.Character:FindFirstChild("Humanoid").DisplayName
                        -- Set to original name
                        v.Character:FindFirstChild("Humanoid").DisplayName = v.Name
                    end
                end
            end)
            -- Handle new players joining
            game:GetService("Players").PlayerAdded:Connect(function(player)
                if player.Character then
                    if player.Character:FindFirstChild("Humanoid") then
                        originalDisplayNames[player.Name] = player.Character:FindFirstChild("Humanoid").DisplayName
                        player.Character:FindFirstChild("Humanoid").DisplayName = player.Name
                    end
                end
                player.CharacterAdded:Connect(function(char)
                    if char:FindFirstChild("Humanoid") then
                        originalDisplayNames[player.Name] = char:FindFirstChild("Humanoid").DisplayName
                        char:FindFirstChild("Humanoid").DisplayName = player.Name
                    end
                end)
            end)
        else
            pcall(function()
                for _, v in pairs(game:GetService("Players"):GetPlayers()) do
                    if v.Character and v.Character:FindFirstChild("Humanoid") then
                        -- Restore original display name
                        if originalDisplayNames[v.Name] then
                            v.Character:FindFirstChild("Humanoid").DisplayName = originalDisplayNames[v.Name]
                        end
                    end
                end
            end)
        end
    end
})

-- Initialize AntiMask variables
local Players = game:GetService("Players")
local isDisplayNameOverrideEnabled = false

-- Function to update player's display name
local function updatePlayerDisplayName(player)
    if not Library.Flags["AntiMaskEnabled"] then
        -- If disabled, return server value
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.DisplayName = nil
        end
        return
    end

    -- If enabled, set DisplayName
    pcall(function()
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.DisplayName = player.DisplayName
        end
    end)
end

-- Function to update all players
local function updateAllPlayers()
    for _, player in pairs(Players:GetPlayers()) do
        updatePlayerDisplayName(player)
    end
end

-- Player added handler
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function()
        updatePlayerDisplayName(player)
    end)
end)

-- Create AntiMask toggle
FeaturesSection:Toggle({
    Name = "AntiMask",
    Default = false,
    Flag = "AntiMaskEnabled",
    Callback = function(value)
        if value then
            spawn(function()
                while Library.Flags["AntiMaskEnabled"] do
                    updateAllPlayers()
                    wait(5)
                end
            end)
            Library:Notification("AntiMask Enabled", 1)
        else
            -- Restore original display names
            for _, player in pairs(Players:GetPlayers()) do
                if player.Character and player.Character:FindFirstChild("Humanoid") then
                    player.Character.Humanoid.DisplayName = nil
                end
            end
            Library:Notification("AntiMask Disabled", 1)
        end
    end
})

-- Initialize InfiniteZoom variables
local Players = game:GetService("Players")
local defaultMaxZoom = Players.LocalPlayer.CameraMaxZoomDistance

-- Create InfiniteZoom toggle
MovementFeaturesSection:Toggle({
    Name = "InfiniteZoom",
    Default = false,
    Flag = "InfiniteZoomEnabled",
    Callback = function(value)
        if value then
            Players.LocalPlayer.CameraMaxZoomDistance = math.huge
            Library:Notification("Infinite Zoom Enabled", 1)
        else
            Players.LocalPlayer.CameraMaxZoomDistance = defaultMaxZoom
            Library:Notification("Infinite Zoom Disabled", 1)
        end
    end
})

-- Initialize NoRecoil variables
local originalNewIndex = nil
local noRecoilEnabled = false

-- Initialize FakeMacro variables
local fakeMacroConfig = {
    enabled = false,
    active = false
}

local function updateCharacterOrientation()
    if not fakeMacroConfig.enabled or not fakeMacroConfig.active then
        return
    end

    local character = Players.LocalPlayer.Character
    if not character then return end

    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end

    local camera = game.Workspace.CurrentCamera
    if not camera then return end

    local cameraDirection = camera.CFrame.LookVector
    humanoidRootPart.CFrame = CFrame.new(humanoidRootPart.Position) * 
        CFrame.Angles(0, math.atan2(-cameraDirection.X, -cameraDirection.Z), 0)
end

-- Create FakeMacro toggle
MovementFeaturesSection:Toggle({
    Name = "FakeMacro",
    Default = false,
    Flag = "FakeMacroEnabled",
    Callback = function(value)
        fakeMacroConfig.enabled = value
        if value then
            -- Setup FakeMacro controls
            UserInputService.InputBegan:Connect(function(input, gameProcessed)
                if input.KeyCode == Enum.KeyCode.LeftControl and not gameProcessed then
                    fakeMacroConfig.active = true
                end
            end)
            
            UserInputService.InputEnded:Connect(function(input, gameProcessed)
                if input.KeyCode == Enum.KeyCode.LeftControl and not gameProcessed then
                    fakeMacroConfig.active = false
                end
            end)

            -- Connect to RunService
            RunService.Heartbeat:Connect(updateCharacterOrientation)
            
            Library:Notification("FakeMacro Enabled", 1)
        else
            fakeMacroConfig.active = false
            Library:Notification("FakeMacro Disabled", 1)
        end
    end
})

-- Helper functions for NoRecoil
local function isframework(scriptInstance)
    if tostring(scriptInstance) == "Framework" then
        return true
    end
    return false
end

local function checkArgs(instance, index)
    if tostring(instance):lower():find("camera") and tostring(index) == "CFrame" then
        return true
    end
    return false
end

-- Create NoRecoil toggle
PlayerFeaturesSection:Toggle({
    Name = "NoRecoil",
    Default = false,
    Flag = "NoRecoilEnabled",
    Callback = function(value)
        if value then
            if not noRecoilEnabled then
                originalNewIndex = hookmetamethod(game, "__newindex", function(self, index, value)
                    local callingScr = getcallingscript()
                    
                    if isframework(callingScr) and checkArgs(self, index) then
                        return
                    end
                    
                    return originalNewIndex(self, index, value)
                end)
                noRecoilEnabled = true
            end
            Library:Notification("NoRecoil Enabled", 1)
        else
            -- Restore original functionality
            if noRecoilEnabled and originalNewIndex then
                hookmetamethod(game, "__newindex", originalNewIndex)
                noRecoilEnabled = false
            end
            Library:Notification("NoRecoil Disabled", 1)
        end
    end
})

-- Initialize ShotSpam variables
local UserInputService = game:GetService("UserInputService")
local isFiring = false
local fireRate = 0.0001

-- Function to reduce cooldowns using debug
local function reduceCooldowns(tool)
    if tool and getconnections then
        for _, connection in ipairs(getconnections(tool.Activated)) do
            local func = connection.Function
            if func then
                local funcInfo = debug.getinfo(func)
                for i = 1, funcInfo.nups do
                    local c, n = debug.getupvalue(func, i)
                    if type(c) == "number" then
                        debug.setupvalue(func, i, 0.01)
                    end
                end
            end
        end
    end
end

-- Function to activate tool
local function activateTool()
    local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
    if tool then
        reduceCooldowns(tool)
        if tool.Activate then
            tool:Activate()
        end
    end
end

-- Create ShotSpam toggle
PlayerFeaturesSection:Toggle({
    Name = "ShotSpam",
    Default = false,
    Flag = "ShotSpamEnabled",
    Callback = function(value)
        if value then
            -- Start the shot spam loop
            spawn(function()
                while Library.Flags["ShotSpamEnabled"] do
                    if isFiring then
                        activateTool()
                    end
                    task.wait(fireRate)
                end
            end)
            Library:Notification("ShotSpam Enabled", 1)
        else
            Library:Notification("ShotSpam Disabled", 1)
        end
    end
})

-- Mouse input tracking
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if input.UserInputType == Enum.UserInputType.MouseButton1 and not gameProcessed then
        isFiring = Library.Flags["ShotSpamEnabled"]
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isFiring = false
    end
end)

-- Initialize AntiFling variables
local antiFlingConnection = nil
local playerAddedConnections = {}
local lastPosition = nil

-- Function to handle player detection and protection
local function handlePlayer(player)
    if player == LocalPlayer then return end
    
    local detected = false
    local character
    local primaryPart
    
    local function onCharacterAdded(newCharacter)
        character = newCharacter
        repeat
            wait()
            primaryPart = newCharacter:FindFirstChild("HumanoidRootPart")
        until primaryPart
        detected = false
    end
    
    local heartbeatConnection
    
    -- Setup character monitoring
    local function setupCharacterMonitoring()
        if heartbeatConnection then heartbeatConnection:Disconnect() end
        
        heartbeatConnection = RunService.Heartbeat:Connect(function()
            if not Library.Flags["AntiFlingEnabled"] then 
                heartbeatConnection:Disconnect()
                return 
            end
            
            if (character and character:IsDescendantOf(workspace)) and (primaryPart and primaryPart:IsDescendantOf(character)) then
                if primaryPart.AssemblyAngularVelocity.Magnitude > 50 or primaryPart.AssemblyLinearVelocity.Magnitude > 100 then
                    if not detected then
                        Library:Notification("Fling Exploit detected: " .. tostring(player), 3)
                    end
                    detected = true
                    
                    for _, v in ipairs(character:GetDescendants()) do
                        if v:IsA("BasePart") then
                            v.CanCollide = false
                            v.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                            v.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                            v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0)
                        end
                    end
                end
            end
        end)
    end
    
    if player.Character then onCharacterAdded(player.Character) end
    player.CharacterAdded:Connect(onCharacterAdded)
    setupCharacterMonitoring()
    
    return heartbeatConnection
end

-- Create AntiFling toggle
PlayerFeaturesSection:Toggle({
    Name = "AntiFling",
    Default = false,
    Flag = "AntiFlingEnabled",
    Callback = function(value)
        if value then
            -- Setup protection for existing players
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= LocalPlayer then
                    playerAddedConnections[player] = handlePlayer(player)
                end
            end
            
            -- Monitor new players
            antiFlingConnection = Players.PlayerAdded:Connect(function(player)
                playerAddedConnections[player] = handlePlayer(player)
            end)
            
            -- Monitor LocalPlayer
            local function monitorLocalPlayer()
                if not LocalPlayer.Character then return end
                local primaryPart = LocalPlayer.Character.PrimaryPart
                if primaryPart then
                    if primaryPart.AssemblyLinearVelocity.Magnitude > 250 or primaryPart.AssemblyAngularVelocity.Magnitude > 250 then
                        primaryPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                        primaryPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                        if lastPosition then
                            primaryPart.CFrame = lastPosition
                        end
                        Library:Notification("Fling attempt blocked!", 1)
                    elseif primaryPart.AssemblyLinearVelocity.Magnitude < 50 then
                        lastPosition = primaryPart.CFrame
                    end
                end
            end
            
            spawn(function()
                while Library.Flags["AntiFlingEnabled"] do
                    pcall(monitorLocalPlayer)
                    task.wait()
                end
            end)
            
            Library:Notification("AntiFling Enabled", 1)
        else
            -- Cleanup all connections
            if antiFlingConnection then
                antiFlingConnection:Disconnect()
                antiFlingConnection = nil
            end
            
            for player, connection in pairs(playerAddedConnections) do
                if connection then
                    connection:Disconnect()
                end
            end
            playerAddedConnections = {}
            
            -- Reset state
            lastPosition = nil
            
            Library:Notification("AntiFling Disabled", 1)
        end
    end
})

-- Initialize ServerJoinScriptShare variables
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")

-- Function to generate teleport script
local function generateTeleportScript()
    local placeId = game.PlaceId
    local jobId = game.JobId
    
    local teleportScript = string.format([[
local TeleportService = game:GetService("TeleportService")
TeleportService:TeleportToPlaceInstance(%d, "%s")
]], placeId, jobId)
    
    return teleportScript
end

-- Create ServerJoinScriptShare button
FeaturesSection:Button({
    Name = "ShareServerScript",
    Callback = function()
        local script = generateTeleportScript()
        
        if setclipboard then
            setclipboard(script)
            Library:Notification("Server join script copied! Now u can share it with friends", 10)
        else
            Library:Notification("Your executor doesn't support clipboard function!", 3)
        end
    end
})

-- Create FunStuff section
local FunStuffSection = MiscPage:Section({
    Name = "Fun Stuff",
    Side = "right"
})

-- Initialize chat variables and functions
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Lists of phrases for Rizz Talk and Ad Talk
local rizzWords = {
    "i want to smash you w my charisma",
    "are u svngle?",
    "u making me corny",
    "wanna make kids?",
    "slide blue app sweety",
    "You make my game lag",
    "Share that drip secret?",
    "When im look at you, im getting corny",
    "Are u french cuz eiffel for you",
    "i like ur arms",
    "ur feets smells good"
}

local adWords = {
    "No skills? Get Full.Skid!",
    "Why lag? Full.Skid wins!",
    "Full.Skid makes you a god!",
    "Lose less with Full.Skid!",
    "Noobs cry, Full.Skid flies!",
    "Rule the map with Full.Skid!",
    "Struggling? Full.Skid's here!",
    "Full.Skid: your win ticket!",
    "Be a pro with Full.Skid!",
    "Full.Skid owns this server!",
    "No aim? Full.Skid's got it!",
    "Full.Skid: noob to legend!",
    "Why try? Full.Skid carries!",
    "Full.Skid: untouchable vibes!",
    "Lose again? Try Full.Skid!",
    "Full.Skid: your skill hack!",
    "Top the board with Full.Skid!",
    "Full.Skid: win every match!",
    "Noobs fear Full.Skid users!",
    "Full.Skid: game changer!",
    "Get good? Nah, Full.Skid!",
    "Full.Skid: pro vibes only!",
    "Outplay all with Full.Skid!",
    "Full.Skid: zero to hero!",
    "Why rage? Full.Skid wins!",
    "Full.Skid: make 'em jealous!",
    "Own the game with Full.Skid!",
    "Full.Skid: no skill needed!",
    "Be unstoppable with Full.Skid!",
    "Full.Skid: your victory key!",
    "No wins? Full.Skid fixes!",
    "Full.Skid: dominate easy!",
    "Get Full.Skid, never lose!",
    "Full.Skid: your aim savior!",
    "Rule servers with Full.Skid!",
    "Full.Skid: top score vibes!",
    "No skill? Full.Skid shines!",
    "Full.Skid: win like a pro!",
    "Full.Skid: your clutch tool!",
    "Make 'em rage with Full.Skid!",
    "Full.Skid: noob destroyer!",
    "Get Full.Skid, flex hard!",
    "Full.Skid: your win streak!",
    "Outshine all with Full.Skid!",
    "Full.Skid: game too easy!",
    "Full.Skid: carry every match!",
    "No luck? Full.Skid's enough!",
    "Full.Skid: be the best!",
    "Win every fight with Full.Skid!",
    "Full.Skid: your pro pass!",
    "Full.Skid: rule or drool!",
    "No aim? Full.Skid nails it!",
    "Full.Skid: top the lobby!",
    "Why fail? Full.Skid prevails!",
    "Full.Skid: your epic edge!",
    "Clutch every game with Full.Skid!",
    "Full.Skid: noob to champ!",
    "Get Full.Skid, own the score!",
    "Full.Skid: make 'em quit!",
    "No wins? Full.Skid delivers!",
    "Full.Skid: your skill boost!",
    "Dominate with Full.Skid now!",
    "Full.Skid: win with ease!",
    "Full.Skid: pro mode on!",
    "Make waves with Full.Skid!",
    "Full.Skid: your top play!",
    "No skill? Full.Skid's got you!",
    "Full.Skid: lead the pack!",
    "Win big with Full.Skid!",
    "Full.Skid: your game hack!",
    "Outplay noobs with Full.Skid!",
    "Full.Skid: victory vibes!",
    "Get Full.Skid, rule the game!",
    "Full.Skid: no fail zone!",
    "Full.Skid: your win spark!",
    "Top every match with Full.Skid!",
    "Full.Skid: skill made easy!",
    "No luck? Full.Skid shines!",
    "Full.Skid: your pro key!",
    "Own every map with Full.Skid!",
    "Full.Skid: win streak mode!",
    "Get Full.Skid, flex big!",
    "Full.Skid: noob to star!",
    "Full.Skid: your clutch king!",
    "Win or cry? Get Full.Skid!",
    "Full.Skid: rule the lobby!",
    "Full.Skid: your aim fix!",
    "No wins? Full.Skid saves!",
    "Full.Skid: top-tier vibes!",
    "Full.Skid: make 'em sweat!",
    "Get Full.Skid, be a legend!",
    "Full.Skid: win every round!",
    "Full.Skid: your epic pass!",
    "No skill? Full.Skid carries!",
    "Full.Skid: dominate now!",
    "Full.Skid: your win edge!",
    "Outshine all with Full.Skid!",
    "Full.Skid: pro play made easy!"
}

local trashWords = {
    "L im crying ",
    "Bozo",
    "Dont u need to aim?",
    "try to look at monitor next time",
    "Ur need to shot in this game btw",
    "Is thats was ping?",
    "Lol",
    "Your skills on cooldown?",
    "When u start to play game?"
}

-- Configuration
local rizzConfig = {
    enabled = false,
    active = false,
    cooldown = 1,
    lastSent = 0
}

local adConfig = {
    enabled = false,
    active = false,
    cooldown = 1,
    lastSent = 0
}

local trashConfig = {
    enabled = false,
    active = false,
    cooldown = 1,
    lastSent = 0
}

-- Get local player and chat event
local player = Players.LocalPlayer
local chatEvent = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("SayMessageRequest")

-- Function to send message
local function sendMessage(words, config)
    local currentTime = tick()
    if currentTime - config.lastSent < config.cooldown then return false end
    if chatEvent and words then
        local randomMessage = words[math.random(1, #words)]
        chatEvent:FireServer(randomMessage, "All")
        config.lastSent = currentTime
        return true
    end
    return false
end

-- Create Rizz Talk toggle
FunStuffSection:Toggle({
    Name = "Rizz Talk",
    Default = false,
    Flag = "RizzTalkEnabled",
    Callback = function(value)
        rizzConfig.enabled = value
        if value then
            Library:Notification("Rizz Talk Enabled", 1)
        else
            rizzConfig.active = false
            Library:Notification("Rizz Talk Disabled", 1)
        end
    end
})

-- Create Rizz Talk keybind
FunStuffSection:Keybind({
    Name = "Rizz Talk Key",
    Default = Enum.KeyCode.R,
    Flag = "RizzTalkKey",
    Mode = "Toggle",
    Callback = function(state)
        if not rizzConfig.enabled then return end
        rizzConfig.active = state
        if state then
            sendMessage(rizzWords, rizzConfig)
        end
    end
})

-- Create Ad Talk toggle
FunStuffSection:Toggle({
    Name = "Ad Talk",
    Default = false,
    Flag = "AdTalkEnabled",
    Callback = function(value)
        adConfig.enabled = value
        if value then
            Library:Notification("Ad Talk Enabled", 1)
        else
            adConfig.active = false
            Library:Notification("Ad Talk Disabled", 1)
        end
    end
})

-- Create Ad Talk keybind
FunStuffSection:Keybind({
    Name = "Ad Talk Key",
    Default = Enum.KeyCode.T,
    Flag = "AdTalkKey",
    Mode = "Toggle",
    Callback = function(state)
        if not adConfig.enabled then return end
        adConfig.active = state
        if state then
            sendMessage(adWords, adConfig)
        end
    end
})

-- Create Trash Talk toggle
FunStuffSection:Toggle({
    Name = "Trash Talk",
    Default = false,
    Flag = "TrashTalkEnabled",
    Callback = function(value)
        trashConfig.enabled = value
        if value then
            Library:Notification("Trash Talk Enabled", 1)
        else
            trashConfig.active = false
            Library:Notification("Trash Talk Disabled", 1)
        end
    end
})

-- Create Trash Talk keybind
FunStuffSection:Keybind({
    Name = "Trash Talk Key",
    Default = Enum.KeyCode.Y,
    Flag = "TrashTalkKey",
    Mode = "Toggle",
    Callback = function(state)
        if not trashConfig.enabled then return end
        trashConfig.active = state
        if state then
            sendMessage(trashWords, trashConfig)
        end
    end
})

-- Main loop for spam handling
RunService.Heartbeat:Connect(function()
    if rizzConfig.enabled and rizzConfig.active then
        sendMessage(rizzWords, rizzConfig)
    end
    if adConfig.enabled and adConfig.active then
        sendMessage(adWords, adConfig)
    end
    if trashConfig.enabled and trashConfig.active then
        sendMessage(trashWords, trashConfig)
    end
end)
