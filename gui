-- Load the MetaGUI library
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/zxcreload/metagui/refs/heads/main/library"))()

-- Create a window
local Window = Library:Window({
    Name = "FULL.SKID"
})

-- Create pages (tabs)
local CombatPage = Window:Page({
    Name = "Combat"
})

local MovementPage = Window:Page({
    Name = "Movement"
})

local VisualsPage = Window:Page({
    Name = "Visuals"
})

local MiscPage = Window:Page({
    Name = "Misc"
})

local ConfigPage = Window:Page({
    Name = "Config"
})

-- Create Config sections
local UISection = ConfigPage:Section({
    Name = "Interface",
    Side = "left"
})

-- GUI Toggle keybind
UISection:Keybind({
    Name = "Toggle GUI",
    Default = Enum.KeyCode.Insert,
    Flag = "ToggleGUI",
    Mode = "Toggle",  -- Явно указываем режим Toggle
    Callback = function(value)
        -- Прямой вызов SetOpen
        Library:SetOpen(value)
    end
})

-- Accent color picker
UISection:Colorpicker({
    Name = "Accent Color",
    Default = Color3.fromRGB(85, 170, 255),
    Flag = "AccentColor",
    Callback = function(Color)
        Library:ChangeAccent(Color)
    end
})

-- Setup Config Manager in the right section
local PresetsSection = ConfigPage:Section({
    Name = "Presets",
    Side = "right"
})

-- Initialize the built-in config manager
Library:SetupConfigManager(ConfigPage)

-- Load all available configurations
Library:LoadAllConfigs()

-- Создаем ватермарк
local Watermark = Library:Watermark({
    Name = "FULL.SKID"
})

-- Создаем секцию для индикатора в Config
local InfoSection = ConfigPage:Section({
    Name = "Display",
    Side = "right"
})

-- Создаем секцию для StaffList в Config
local StaffSection = ConfigPage:Section({
    Name = "Staff",
    Side = "left"
})

-- Создаем индикатор через библиотеку
local Indicator = Library:Indicator({
    Name = "FULL.SKID" -- Индикатор можно перемещать мышкой
})

-- Создаем StaffList
local StaffList = Library:StaffList({
    Name = "Staff List" -- Список персонала можно перемещать мышкой
})

-- Устанавливаем начальную позицию индикатора по центру экрана
Indicator:SetPosition("top")

-- Список вариантов информации для индикатора
local IndicatorOptions = {
    "coordinates",
    "state",
    "ping",
    "speed"
}

-- Toggle для включения/выключения индикатора
InfoSection:Toggle({
    Name = "Indicator",
    Default = false,
    Flag = "IndicatorEnabled",
    Callback = function(Value)
        -- Показываем/скрываем индикатор
        Indicator:SetVisible(Value)
        
        -- При включении обновляем отображаемые элементы
        if Value then
            UpdateIndicatorElements()
        end
    end
})

-- Выбор информации для индикатора
InfoSection:List({
    Name = "Info Elements",
    Options = IndicatorOptions,
    Default = {},
    Max = #IndicatorOptions,
    Flag = "IndicatorInfo",
    Callback = function(Selected)
        if Library.Flags["IndicatorEnabled"] then
            UpdateIndicatorElements()
        end
    end
})

-- Toggle для включения/выключения StaffList
StaffSection:Toggle({
    Name = "Staff List",
    Default = false,
    Flag = "StaffListEnabled",
    Callback = function(Value)
        -- Показываем/скрываем StaffList
        StaffList:SetVisible(Value)
    end
})

-- Функция для получения FPS
local function GetFPS()
    return math.floor(1/game:GetService("RunService").RenderStepped:Wait())
end

-- Список вариантов информации для ватермарка
local WatermarkOptions = {
    "client",
    "username",
    "fps",
    "time",
    "date"
}

-- Переменные для отслеживания движения
local lastPosition = nil
local isMoving = false
local movementThreshold = 0.05 -- Порог для определения движения

-- Функция для получения координат персонажа
local function GetCoordinates()
    local player = game:GetService("Players").LocalPlayer
    if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local pos = player.Character.HumanoidRootPart.Position
        return string.format("%d,%d,%d", math.floor(pos.X), math.floor(pos.Y), math.floor(pos.Z))
    end
    return "N/A"
end

-- Функция для определения скорости персонажа
local function GetSpeed()
    local player = game:GetService("Players").LocalPlayer
    if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local humanoidRootPart = player.Character.HumanoidRootPart
        -- Вычисляем только горизонтальную скорость (без учета вертикали)
        local velocity = humanoidRootPart.Velocity
        local horizSpeed = math.sqrt(velocity.X^2 + velocity.Z^2)
        return string.format("%d s/s", math.floor(horizSpeed))
    end
    return "N/A"
end

-- Функция для получения состояния персонажа (в воздухе или на земле)
local function GetState()
    local player = game:GetService("Players").LocalPlayer
    if player and player.Character then
        local humanoid = player.Character:FindFirstChild("Humanoid")
        
        if humanoid then
            -- Проверяем, находится ли персонаж на земле
            if humanoid.FloorMaterial == Enum.Material.Air then
                return "Air"
                else
                return "Ground"
            end
        end
    end
    return "N/A"
end

-- Функция для получения пинга
local function GetPing()
    local stats = game:GetService("Stats")
    local ping = math.floor(stats.Network.ServerStatsItem["Data Ping"]:GetValue())
    return ping .. "ms"
end

-- Функция для форматирования времени
local function GetTimeFormatted()
    local time = os.date("*t")
    return string.format("%02d:%02d:%02d", time.hour, time.min, time.sec)
end

-- Функция для форматирования даты
local function GetDateFormatted()
    local date = os.date("*t")
    return string.format("%02d/%02d/%d", date.day, date.month, date.year)
end

-- Функция для обновления содержимого индикатора на основе выбранных опций
function UpdateIndicatorElements()
    -- Получаем выбранные опции
    local selectedOptions = Library.Flags["IndicatorInfo"] or {}
    
    -- Если список опций пуст, очищаем индикатор и завершаем функцию
    if #selectedOptions == 0 then
    Indicator:ClearAll()
        return
    end
    
    -- Создаем таблицу для быстрой проверки
    local optionsMap = {}
    for _, option in ipairs(selectedOptions) do
        optionsMap[option] = true
    end
    
    -- Находим элементы, которые нужно удалить (те, которые есть, но не выбраны)
    for _, key in ipairs({"coordinates", "state", "ping", "speed"}) do
        if Indicator:HasElement(key) and not optionsMap[key] then
            Indicator:RemoveElement(key)
        end
    end
    
    -- Добавляем или обновляем выбранные элементы
    if optionsMap["coordinates"] then
            Indicator:NewValue({
                Key = "coordinates",
                Name = "Coords:",
                Value = GetCoordinates()
            })
    end
    
    if optionsMap["state"] then
            Indicator:NewValue({
                Key = "state",
            Name = "Air/Ground:",
                Value = GetState()
            })
    end
    
    if optionsMap["ping"] then
            Indicator:NewValue({
                Key = "ping",
                Name = "Ping:",
                Value = GetPing()
            })
    end
    
    if optionsMap["speed"] then
            Indicator:NewValue({
                Key = "speed",
                Name = "Speed:",
                Value = GetSpeed()
            })
    end
end

-- Функция для периодического обновления значений индикатора
spawn(function()
    while wait(0.1) do
        if Library.Flags["IndicatorEnabled"] then
            -- Получаем выбранные опции
            local selectedOptions = Library.Flags["IndicatorInfo"] or {}
            
            -- Если нет выбранных опций, пропускаем
            if #selectedOptions == 0 then
                continue
            end
            
            -- Создаем таблицу для быстрой проверки
            local optionsMap = {}
            for _, option in ipairs(selectedOptions) do
                optionsMap[option] = true
            end
            
            -- Безопасно обновляем каждое значение, только если оно выбрано и существует
            if optionsMap["coordinates"] and Indicator:HasElement("coordinates") then
                Indicator:SafeUpdateValue("coordinates", GetCoordinates())
            end
            
            if optionsMap["state"] and Indicator:HasElement("state") then
                Indicator:SafeUpdateValue("state", GetState())
            end
            
            if optionsMap["ping"] and Indicator:HasElement("ping") then
                Indicator:SafeUpdateValue("ping", GetPing())
            end
            
            if optionsMap["speed"] and Indicator:HasElement("speed") then
                Indicator:SafeUpdateValue("speed", GetSpeed())
            end
        end
    end
end)

-- Функция для обновления текста ватермарка
local function UpdateWatermark()
    -- Получаем выбранные опции
    local selectedOptions = Library.Flags["WatermarkInfo"] or {}
    if #selectedOptions == 0 then
        Watermark:UpdateText("Select watermark info ")
        return
    end
    
    -- Создаем таблицу для компонентов в правильном порядке
    local components = {}
    
    -- Проверяем каждую опцию в порядке, указанном пользователем
    for _, option in ipairs(WatermarkOptions) do
        if table.find(selectedOptions, option) then
            if option == "client" then
                table.insert(components, "FULL.SKID")
            elseif option == "username" then
                local player = game:GetService("Players").LocalPlayer
                table.insert(components, player and player.Name or "User")
            elseif option == "fps" then
                table.insert(components, "FPS: " .. GetFPS())
            elseif option == "time" then
                table.insert(components, GetTimeFormatted())
            elseif option == "date" then
                table.insert(components, GetDateFormatted())
            end
        end
    end
    
    -- Объединяем все компоненты в одну строку с разделителем и добавляем отступ в конце
    Watermark:UpdateText(table.concat(components, " | ") .. " ")
end

-- Функция для установки позиции ватермарки
local function SetWatermarkPosition(position)
    if Watermark then
        -- Просто вызываем метод SetPosition из библиотеки
        Watermark:SetPosition(position)
    end
end

-- Добавляем управление ватермарком в секцию Presets
PresetsSection:Toggle({
    Name = "Watermark",
    Default = false,
    Flag = "WatermarkEnabled",
    Callback = function(Value)
        if Watermark then
            Watermark:SetVisible(Value)
            -- При включении сразу обновляем текст
            if Value then
                UpdateWatermark()
                -- Применяем текущую выбранную позицию
                SetWatermarkPosition(Library.Flags["WatermarkPosition"] or "left")
            end
        end
    end
})

-- Список вариантов позиций для ватермарка
local PositionOptions = {
    "left",
    "right",
    "bottom",
    "top"
}

-- Добавляем выбор позиции для ватермарка
PresetsSection:List({
    Name = "WM Position",
    Options = PositionOptions,
    Default = "left",
    Flag = "WatermarkPosition",
    Callback = function(Selected)
        if Library.Flags["WatermarkEnabled"] and Watermark then
            -- Используем новую функцию для позиционирования
            SetWatermarkPosition(Selected)
        end
    end
})

-- Создаем мультибокс для выбора информации ватермарка
PresetsSection:List({
    Name = "WM Content",
    Options = WatermarkOptions,
    Default = {},
    Max = #WatermarkOptions, -- Разрешаем выбрать все опции
    Flag = "WatermarkInfo",
    Callback = function(Selected)
        UpdateWatermark()
    end
})

-- Функция для периодического обновления ватермарка
spawn(function()
    while wait(1) do
        if Library.Flags["WatermarkEnabled"] and Watermark then
            UpdateWatermark()
        end
    end
end)

-- Создаем секцию для Keybinds List в Config
local KeybindsSection = ConfigPage:Section({
    Name = "Keybinds",
    Side = "left"
})

-- Создаем KeybindsList
local KeybindsList = Library:KeybindsList({
    Name = "Keybinds List",
    Flags = {} -- Заполним после выбора
})

-- Устанавливаем начальную позицию в правом верху экрана
KeybindsList:SetPosition("right")

-- Список доступных кейбиндов (флаги и названия)
local AvailableKeybinds = {
    {Flag = "ToggleGUI", Name = "Toggle GUI"},
    -- Добавь сюда свои кейбинды, если появятся новые
}

local KeybindFlags = {}
local KeybindNames = {}
for _, v in ipairs(AvailableKeybinds) do
    table.insert(KeybindFlags, v.Flag)
    table.insert(KeybindNames, v.Name)
end

-- Toggle для включения/выключения Keybinds List
KeybindsSection:Toggle({
    Name = "Keybinds List",
    Default = false,
    Flag = "KeybindsListEnabled",
    Callback = function(Value)
        KeybindsList:SetVisible(Value)
        
        -- При включении обновляем отображаемые элементы
        if Value then
            local selectedFlags = {}
            local selectedOptions = Library.Flags["KeybindsListFlags"] or {}
            
            for i, name in ipairs(KeybindNames) do
                if table.find(selectedOptions, name) then
                    table.insert(selectedFlags, KeybindFlags[i])
                end
            end
            
            KeybindsList:SetFlags(selectedFlags)
        end
    end
})

-- Мультибокс для выбора отображаемых кейбиндов
KeybindsSection:List({
    Name = "Show Keybinds",
    Options = KeybindNames,
    Default = {KeybindNames[1]}, -- По умолчанию выбираем первый кейбинд
    Max = #KeybindNames,
    Flag = "KeybindsListFlags",
    Callback = function(selected)
        -- Преобразуем выбранные имена в флаги
        local selectedFlags = {}
        for i, name in ipairs(KeybindNames) do
            if table.find(selected, name) then
                table.insert(selectedFlags, KeybindFlags[i])
            end
        end
        KeybindsList:SetFlags(selectedFlags)
    end
})

-- Create a notification to show the UI is loaded
Library:Notification("UI loaded successfully", 3)

-- Manually add InputBegan event for Insert key as backup toggle
game:GetService("UserInputService").InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.Insert then
        Library:SetOpen(not Library.Open)
    end
end)

-- Create Misc sections
local FeaturesSection = MiscPage:Section({
    Name = "Features",
    Side = "left"
})

-- Create Player Features section
local PlayerFeaturesSection = MiscPage:Section({
    Name = "Player Features",
    Side = "left"
})

-- Initialize Desync variables and functions
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local LocalPlayer = Players.LocalPlayer
local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local playerName = LocalPlayer.Name

-- Desync settings and variables
local Settings = {
    AntiAim = {
        FFlagDesync = {
            Enabled = true,
            Amount = 20,
            SetNew = true,
            SetNewAmount = 60,
            FFlags = {
                ["S2PhysicsSenderRate"] = true,
                ["PhysicsSenderMaxBandwidthBps"] = false,
                ["DataSenderMaxJoinBandwidthBps"] = false
            }
        }
    }
}

local state = false
local defaultFFlagValues = {}
local currentClone = nil

local Script = {}
Script.Functions = {}

-- Save default FFlag values
Script.Functions.SaveDefaultFFlags = function()
    for FFlag, _ in pairs(Settings.AntiAim.FFlagDesync.FFlags) do
        defaultFFlagValues[FFlag] = getfflag(FFlag) or "0"
    end
end

-- Apply/reset desync
Script.Functions.FFlagDesync = function()
    if not Settings.AntiAim.FFlagDesync.Enabled then return end

    for FFlag, _ in pairs(Settings.AntiAim.FFlagDesync.FFlags) do
        if state then
            local Value = Settings.AntiAim.FFlagDesync.Amount
            setfflag(FFlag, tostring(Value))
            RunService.RenderStepped:Wait()
            if Settings.AntiAim.FFlagDesync.SetNew then
                setfflag(FFlag, tostring(Settings.AntiAim.FFlagDesync.SetNewAmount))
            end
        else
            if defaultFFlagValues[FFlag] then
                setfflag(FFlag, defaultFFlagValues[FFlag])
            end
        end
    end
end

-- Reset clone and desync
local function resetClone()
    if currentClone then
        currentClone:Destroy()
        currentClone = nil
    end
    state = false
    Script.Functions.FFlagDesync()
end

-- Create visual clone
local function createVisualClone()
    if currentClone then
        currentClone:Destroy()
    end
    
    local cloneModel = Instance.new("Model")
    cloneModel.Name = "0x78"
    local partMap = {}
    local originalHRP = character:WaitForChild("HumanoidRootPart")
    local cloneHRP = nil

    local function disableCollision(obj)
        for _, part in pairs(obj:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
                part.Anchored = true
                part.CanTouch = false
                part.Massless = true
            end
        end
    end

    -- Copy body parts excluding tools
    for _, child in pairs(character:GetDescendants()) do
        if child:IsA("BasePart") and not child.Parent:IsA("Accessory") and not child:IsA("Tool") and not child.Parent:IsA("Tool") then
            local clonePart = child:Clone()
            for _, descendant in pairs(clonePart:GetDescendants()) do
                if descendant:IsA("Motor6D") or descendant:IsA("Weld") then
                    descendant:Destroy()
                end
            end
            if clonePart.Name == "Head" and clonePart:IsA("MeshPart") then
                clonePart.TextureID = ""
            end
            clonePart.CanCollide = false
            clonePart.Anchored = true
            clonePart.CanTouch = false
            clonePart.Massless = true
            clonePart.Parent = cloneModel
            partMap[clonePart] = child
            if clonePart.Name == "HumanoidRootPart" then
                cloneHRP = clonePart
            end
        elseif child:IsA("Accessory") then
            local cloneAccessory = child:Clone()
            for _, accessoryPart in pairs(cloneAccessory:GetDescendants()) do
                if accessoryPart:IsA("Motor6D") or accessoryPart:IsA("Weld") or accessoryPart:IsA("Attachment") then
                    accessoryPart:Destroy()
                end
                if accessoryPart:IsA("BasePart") then
                    accessoryPart.CanCollide = false
                    accessoryPart.Anchored = true
                    accessoryPart.CanTouch = false
                    accessoryPart.Massless = true
                    local originalHandle = child:FindFirstChildWhichIsA("BasePart")
                    if originalHandle then
                        partMap[accessoryPart] = originalHandle
                    end
                end
            end
            cloneAccessory.Parent = cloneModel
        end
    end

    -- Copy clothing
    local playerPath = workspace:WaitForChild("Players"):WaitForChild(playerName)
    if playerPath:FindFirstChild("Pants") then
        local pantsClone = playerPath.Pants:Clone()
        pantsClone.Parent = cloneModel
    end
    if playerPath:FindFirstChild("Shirt") then
        local shirtClone = playerPath.Shirt:Clone()
        shirtClone.Parent = cloneModel
    end

    -- Final collision check
    disableCollision(cloneModel)
    cloneModel.PrimaryPart = cloneHRP
    cloneModel.Parent = workspace
    currentClone = cloneModel

    -- Freeze clone in current state
    for clonedPart, originalPart in pairs(partMap) do
        clonedPart.CFrame = originalPart.CFrame
    end

    -- Monitor clone changes
    cloneModel.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("BasePart") then
            descendant.CanCollide = false
            descendant.Anchored = true
            descendant.CanTouch = false
            descendant.Massless = true
        end
    end)
end

-- Character death handler
local function onCharacterDeath()
    resetClone()
end

-- Character respawn handler
local function onCharacterAdded(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    humanoid.Died:Connect(onCharacterDeath)
end

-- Subscribe to death and respawn events
humanoid.Died:Connect(onCharacterDeath)
LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

-- Create Desync toggle and keybind
local DesyncToggle = PlayerFeaturesSection:Toggle({
    Name = "Desync",
    Default = false,
    Flag = "DesyncEnabled",
    Callback = function(Value)
        if Value and Library.Flags["BlinkEnabled"] then
            -- Show 10 warning notifications if trying to enable both
            for i = 1, 10 do
                Library:Notification("WARNING: Using both Desync and Blink may cause bugs! You were warned!", 1)
                wait(0.1)
            end
            -- Force disable the toggle
            DesyncToggle:Set(false)
            return
        end
        
        if not Value then
            -- When toggle is disabled, force disable desync
            state = false
            resetClone()
        end
    end
})

-- Create Desync keybind
PlayerFeaturesSection:Keybind({
    Name = "Desync Key",
    Flag = "DesyncKey",
    Mode = "Hold", -- Changed to Hold mode
    Callback = function(keyState)
        -- Only process keybind if desync is enabled via toggle
        if not Library.Flags["DesyncEnabled"] then return end
        
        -- Update state based on key state
        if keyState then
            if not state then -- Only create clone if not already created
                state = true
                createVisualClone()
                Script.Functions.FFlagDesync()
                Library:Notification("Desync Enabled", 1)
            end
        else
            if state then -- Only reset if currently active
                resetClone()
                Library:Notification("Desync Disabled", 1)
            end
        end
    end
})

-- Save initial FFlags
Script.Functions.SaveDefaultFFlags()

-- Continue heartbeat monitoring
RunService.Heartbeat:Connect(function()
    if state and humanoid.Health > 0 then
        Script.Functions.FFlagDesync()
    elseif state and humanoid.Health <= 0 then
        resetClone()
    end
end)

-- Add desync to available keybinds list
table.insert(AvailableKeybinds, {Flag = "DesyncKey", Name = "Desync"})
-- Update KeybindFlags and KeybindNames
KeybindFlags = {}
KeybindNames = {}
for _, v in ipairs(AvailableKeybinds) do
    table.insert(KeybindFlags, v.Flag)
    table.insert(KeybindNames, v.Name)
end

-- Initialize Blink variables and functions
local BlinkSettings = {
    Enabled = false,
    FreezeTime = 0.5,
    UnfreezeTime = 0.05
}

local blinkState = false
local isBlinkFrozen = false
local blinkThread = nil

-- Blink functions
local function clearBlinkClone()
    if currentClone then
        currentClone:Destroy()
        currentClone = nil
    end
end

local function resetBlink()
    if blinkThread then
        coroutine.close(blinkThread)
        blinkThread = nil
    end
    blinkState = false
    isBlinkFrozen = false
    clearBlinkClone()
    Script.Functions.FFlagDesync()
end

local function runBlinkCycle()
    while blinkState and humanoid.Health > 0 do
        if not character or not character.Parent then
            resetBlink()
            break
        end
        -- Start freeze
        isBlinkFrozen = true
        createVisualClone()
        wait(BlinkSettings.FreezeTime)
        -- End freeze, start unfreeze
        isBlinkFrozen = false
        clearBlinkClone()
        Script.Functions.FFlagDesync()
        wait(BlinkSettings.UnfreezeTime)
    end
    isBlinkFrozen = false
    Script.Functions.FFlagDesync()
end

-- Create Blink toggle
local BlinkToggle = PlayerFeaturesSection:Toggle({
    Name = "Blink",
    Default = false,
    Flag = "BlinkEnabled",
    Callback = function(Value)
        if Value and Library.Flags["DesyncEnabled"] then
            -- Show 10 warning notifications if trying to enable both
            for i = 1, 10 do
                Library:Notification("WARNING: Using both Desync and Blink may cause bugs! You were warned!", 1)
                wait(0.1)
            end
            -- Force disable the toggle
            BlinkToggle:Set(false)
            return
        end

        BlinkSettings.Enabled = Value
        if Value then
            blinkState = false  -- Reset state before potentially starting
            if Library.Flags["BlinkKey"] then  -- If key is already held when enabling
                blinkState = true
                blinkThread = coroutine.create(runBlinkCycle)
                coroutine.resume(blinkThread)
            end
        else
            resetBlink()
        end
    end
})

-- Create Blink latency control
PlayerFeaturesSection:Textbox({
    Name = "Latency (s)",
    Default = "0.5",
    Flag = "BlinkLatency",
    Callback = function(Value)
        local num = tonumber(Value)
        if num and num > 0 then
            BlinkSettings.FreezeTime = num
        end
    end
})

-- Create Blink keybind
PlayerFeaturesSection:Keybind({
    Name = "Blink Key",
    Flag = "BlinkKey",
    Mode = "Hold",
    Callback = function(keyState)
        if not Library.Flags["BlinkEnabled"] then return end
        
        if keyState then
            if not blinkState then
                blinkState = true
                blinkThread = coroutine.create(runBlinkCycle)
                coroutine.resume(blinkThread)
                Library:Notification("Blink Enabled", 1)
            end
        else
            if blinkState then
                resetBlink()
                Library:Notification("Blink Disabled", 1)
            end
        end
    end
})

-- Add blink to available keybinds list
table.insert(AvailableKeybinds, {Flag = "BlinkKey", Name = "Blink"})
-- Update KeybindFlags and KeybindNames
KeybindFlags = {}
KeybindNames = {}
for _, v in ipairs(AvailableKeybinds) do
    table.insert(KeybindFlags, v.Flag)
    table.insert(KeybindNames, v.Name)
end

-- Variable to hold the Anti AFK connection
local antiAfkConnection = nil

-- Anti AFK Toggle
FeaturesSection:Toggle({
    Name = "Anti AFK",
    Default = false,
    Flag = "AntiAFKEnabled",
    Callback = function(value)
        local VirtualUser = game:GetService("VirtualUser")
        local LocalPlayer = game:GetService("Players").LocalPlayer

        if value then -- Enable Anti AFK
            if LocalPlayer and antiAfkConnection == nil then
                antiAfkConnection = LocalPlayer.Idled:Connect(function()
                    VirtualUser:CaptureController()
                    VirtualUser:ClickButton2(Vector2.new())
                end)
            end
        else -- Disable Anti AFK
            if antiAfkConnection ~= nil then
                antiAfkConnection:Disconnect()
                antiAfkConnection = nil
            end
        end
    end
})
