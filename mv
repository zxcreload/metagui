-- Load the MetaGUI library
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/zxcreload/metagui/refs/heads/main/library"))()

-- Create a window
local Window = Library:Window({
    Name = "FULL.SKID"
})

-- Create pages (tabs)
local CombatPage = Window:Page({
    Name = "Combat"
})

local MovementPage = Window:Page({
    Name = "Movement"
})

local VisualsPage = Window:Page({
    Name = "Visuals"
})

local MiscPage = Window:Page({
    Name = "Misc"
})

local ConfigPage = Window:Page({
    Name = "Config"
})

-- Create Config sections
local UISection = ConfigPage:Section({
    Name = "Interface",
    Side = "left"
})

-- GUI Toggle keybind
UISection:Keybind({
    Name = "Toggle GUI",
    Default = Enum.KeyCode.Insert,
    Flag = "ToggleGUI",
    Mode = "Toggle",  -- Явно указываем режим Toggle
    Callback = function(value)
        -- Прямой вызов SetOpen
        Library:SetOpen(value)
    end
})

-- Accent color picker
UISection:Colorpicker({
    Name = "Accent Color",
    Default = Color3.fromRGB(85, 170, 255),
    Flag = "AccentColor",
    Callback = function(Color)
        Library:ChangeAccent(Color)
    end
})

-- Setup Config Manager in the right section
local PresetsSection = ConfigPage:Section({
    Name = "Presets",
    Side = "right"
})

-- Initialize the built-in config manager
Library:SetupConfigManager(ConfigPage)

-- Load all available configurations
Library:LoadAllConfigs()

-- Создаем ватермарк
local Watermark = Library:Watermark({
    Name = "FULL.SKID"
})

-- Создаем секцию для индикатора в Config
local InfoSection = ConfigPage:Section({
    Name = "Display",
    Side = "right"
})

-- Создаем секцию для StaffList в Config
local StaffSection = ConfigPage:Section({
    Name = "Staff",
    Side = "left"
})

-- Создаем индикатор через библиотеку
local Indicator = Library:Indicator({
    Name = "FULL.SKID" -- Индикатор можно перемещать мышкой
})

-- Создаем StaffList
local StaffList = Library:StaffList({
    Name = "Staff List" -- Список персонала можно перемещать мышкой
})

-- Устанавливаем начальную позицию индикатора по центру экрана
Indicator:SetPosition("top")

-- Список вариантов информации для индикатора
local IndicatorOptions = {
    "coordinates",
    "state",
    "ping",
    "speed"
}

-- Toggle для включения/выключения индикатора
InfoSection:Toggle({
    Name = "Indicator",
    Default = false,
    Flag = "IndicatorEnabled",
    Callback = function(Value)
        -- Показываем/скрываем индикатор
        Indicator:SetVisible(Value)
        
        -- При включении обновляем отображаемые элементы
        if Value then
            UpdateIndicatorElements()
        end
    end
})

-- Выбор информации для индикатора
InfoSection:List({
    Name = "Info Elements",
    Options = IndicatorOptions,
    Default = {},
    Max = #IndicatorOptions,
    Flag = "IndicatorInfo",
    Callback = function(Selected)
        if Library.Flags["IndicatorEnabled"] then
            UpdateIndicatorElements()
        end
    end
})

-- Toggle для включения/выключения StaffList
StaffSection:Toggle({
    Name = "Staff List",
    Default = false,
    Flag = "StaffListEnabled",
    Callback = function(Value)
        -- Показываем/скрываем StaffList
        StaffList:SetVisible(Value)
    end
})

-- Функция для получения FPS
local function GetFPS()
    return math.floor(1/game:GetService("RunService").RenderStepped:Wait())
end

-- Список вариантов информации для ватермарка
local WatermarkOptions = {
    "client",
    "username",
    "fps",
    "time",
    "date"
}

-- Переменные для отслеживания движения
local lastPosition = nil
local isMoving = false
local movementThreshold = 0.05 -- Порог для определения движения

-- Функция для получения координат персонажа
local function GetCoordinates()
    local player = game:GetService("Players").LocalPlayer
    if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local pos = player.Character.HumanoidRootPart.Position
        return string.format("%d,%d,%d", math.floor(pos.X), math.floor(pos.Y), math.floor(pos.Z))
    end
    return "N/A"
end

-- Функция для определения скорости персонажа
local function GetSpeed()
    local player = game:GetService("Players").LocalPlayer
    if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local humanoidRootPart = player.Character.HumanoidRootPart
        -- Вычисляем только горизонтальную скорость (без учета вертикали)
        local velocity = humanoidRootPart.Velocity
        local horizSpeed = math.sqrt(velocity.X^2 + velocity.Z^2)
        return string.format("%d s/s", math.floor(horizSpeed))
    end
    return "N/A"
end

-- Функция для получения состояния персонажа (в воздухе или на земле)
local function GetState()
    local player = game:GetService("Players").LocalPlayer
    if player and player.Character then
        local humanoid = player.Character:FindFirstChild("Humanoid")
        
        if humanoid then
            -- Проверяем, находится ли персонаж на земле
            if humanoid.FloorMaterial == Enum.Material.Air then
                return "Air"
                else
                return "Ground"
            end
        end
    end
    return "N/A"
end

-- Функция для получения пинга
local function GetPing()
    local stats = game:GetService("Stats")
    local ping = math.floor(stats.Network.ServerStatsItem["Data Ping"]:GetValue())
    return ping .. "ms"
end

-- Функция для форматирования времени
local function GetTimeFormatted()
    local time = os.date("*t")
    return string.format("%02d:%02d:%02d", time.hour, time.min, time.sec)
end

-- Функция для форматирования даты
local function GetDateFormatted()
    local date = os.date("*t")
    return string.format("%02d/%02d/%d", date.day, date.month, date.year)
end

-- Функция для обновления содержимого индикатора на основе выбранных опций
function UpdateIndicatorElements()
    -- Получаем выбранные опции
    local selectedOptions = Library.Flags["IndicatorInfo"] or {}
    
    -- Если список опций пуст, очищаем индикатор и завершаем функцию
    if #selectedOptions == 0 then
    Indicator:ClearAll()
        return
    end
    
    -- Создаем таблицу для быстрой проверки
    local optionsMap = {}
    for _, option in ipairs(selectedOptions) do
        optionsMap[option] = true
    end
    
    -- Находим элементы, которые нужно удалить (те, которые есть, но не выбраны)
    for _, key in ipairs({"coordinates", "state", "ping", "speed"}) do
        if Indicator:HasElement(key) and not optionsMap[key] then
            Indicator:RemoveElement(key)
        end
    end
    
    -- Добавляем или обновляем выбранные элементы
    if optionsMap["coordinates"] then
            Indicator:NewValue({
                Key = "coordinates",
                Name = "Coords:",
                Value = GetCoordinates()
            })
    end
    
    if optionsMap["state"] then
            Indicator:NewValue({
                Key = "state",
            Name = "Air/Ground:",
                Value = GetState()
            })
    end
    
    if optionsMap["ping"] then
            Indicator:NewValue({
                Key = "ping",
                Name = "Ping:",
                Value = GetPing()
            })
    end
    
    if optionsMap["speed"] then
            Indicator:NewValue({
                Key = "speed",
                Name = "Speed:",
                Value = GetSpeed()
            })
    end
end

-- Функция для периодического обновления значений индикатора
spawn(function()
    while wait(0.1) do
        if Library.Flags["IndicatorEnabled"] then
            -- Получаем выбранные опции
            local selectedOptions = Library.Flags["IndicatorInfo"] or {}
            
            -- Если нет выбранных опций, пропускаем
            if #selectedOptions == 0 then
                continue
            end
            
            -- Создаем таблицу для быстрой проверки
            local optionsMap = {}
            for _, option in ipairs(selectedOptions) do
                optionsMap[option] = true
            end
            
            -- Безопасно обновляем каждое значение, только если оно выбрано и существует
            if optionsMap["coordinates"] and Indicator:HasElement("coordinates") then
                Indicator:SafeUpdateValue("coordinates", GetCoordinates())
            end
            
            if optionsMap["state"] and Indicator:HasElement("state") then
                Indicator:SafeUpdateValue("state", GetState())
            end
            
            if optionsMap["ping"] and Indicator:HasElement("ping") then
                Indicator:SafeUpdateValue("ping", GetPing())
            end
            
            if optionsMap["speed"] and Indicator:HasElement("speed") then
                Indicator:SafeUpdateValue("speed", GetSpeed())
            end
        end
    end
end)

-- Функция для обновления текста ватермарка
local function UpdateWatermark()
    -- Получаем выбранные опции
    local selectedOptions = Library.Flags["WatermarkInfo"] or {}
    if #selectedOptions == 0 then
        Watermark:UpdateText("Select watermark info ")
        return
    end
    
    -- Создаем таблицу для компонентов в правильном порядке
    local components = {}
    
    -- Проверяем каждую опцию в порядке, указанном пользователем
    for _, option in ipairs(WatermarkOptions) do
        if table.find(selectedOptions, option) then
            if option == "client" then
                table.insert(components, "FULL.SKID")
            elseif option == "username" then
                local player = game:GetService("Players").LocalPlayer
                table.insert(components, player and player.Name or "User")
            elseif option == "fps" then
                table.insert(components, "FPS: " .. GetFPS())
            elseif option == "time" then
                table.insert(components, GetTimeFormatted())
            elseif option == "date" then
                table.insert(components, GetDateFormatted())
            end
        end
    end
    
    -- Объединяем все компоненты в одну строку с разделителем и добавляем отступ в конце
    Watermark:UpdateText(table.concat(components, " | ") .. " ")
end

-- Функция для установки позиции ватермарки
local function SetWatermarkPosition(position)
    if Watermark then
        -- Просто вызываем метод SetPosition из библиотеки
        Watermark:SetPosition(position)
    end
end

-- Добавляем управление ватермарком в секцию Presets
PresetsSection:Toggle({
    Name = "Watermark",
    Default = false,
    Flag = "WatermarkEnabled",
    Callback = function(Value)
        if Watermark then
            Watermark:SetVisible(Value)
            -- При включении сразу обновляем текст
            if Value then
                UpdateWatermark()
                -- Применяем текущую выбранную позицию
                SetWatermarkPosition(Library.Flags["WatermarkPosition"] or "left")
            end
        end
    end
})

-- Список вариантов позиций для ватермарка
local PositionOptions = {
    "left",
    "right",
    "bottom",
    "top"
}

-- Добавляем выбор позиции для ватермарка
PresetsSection:List({
    Name = "WM Position",
    Options = PositionOptions,
    Default = "left",
    Flag = "WatermarkPosition",
    Callback = function(Selected)
        if Library.Flags["WatermarkEnabled"] and Watermark then
            -- Используем новую функцию для позиционирования
            SetWatermarkPosition(Selected)
        end
    end
})

-- Создаем мультибокс для выбора информации ватермарка
PresetsSection:List({
    Name = "WM Content",
    Options = WatermarkOptions,
    Default = {},
    Max = #WatermarkOptions, -- Разрешаем выбрать все опции
    Flag = "WatermarkInfo",
    Callback = function(Selected)
        UpdateWatermark()
    end
})

-- Функция для периодического обновления ватермарка
spawn(function()
    while wait(1) do
        if Library.Flags["WatermarkEnabled"] and Watermark then
            UpdateWatermark()
        end
    end
end)

-- Создаем секцию для Keybinds List в Config
local KeybindsSection = ConfigPage:Section({
    Name = "Keybinds",
    Side = "left"
})

-- Создаем KeybindsList
local KeybindsList = Library:KeybindsList({
    Name = "Keybinds List",
    Flags = {} -- Заполним после выбора
})

-- Устанавливаем начальную позицию в правом верху экрана
KeybindsList:SetPosition("right")

-- Список доступных кейбиндов (флаги и названия)
local AvailableKeybinds = {
    {Flag = "ToggleGUI", Name = "Toggle GUI"},
    -- Добавь сюда свои кейбинды, если появятся новые
}

local KeybindFlags = {}
local KeybindNames = {}
for _, v in ipairs(AvailableKeybinds) do
    table.insert(KeybindFlags, v.Flag)
    table.insert(KeybindNames, v.Name)
end

-- Toggle для включения/выключения Keybinds List
KeybindsSection:Toggle({
    Name = "Keybinds List",
    Default = false,
    Flag = "KeybindsListEnabled",
    Callback = function(Value)
        KeybindsList:SetVisible(Value)
        
        -- При включении обновляем отображаемые элементы
        if Value then
            local selectedFlags = {}
            local selectedOptions = Library.Flags["KeybindsListFlags"] or {}
            
            for i, name in ipairs(KeybindNames) do
                if table.find(selectedOptions, name) then
                    table.insert(selectedFlags, KeybindFlags[i])
                end
            end
            
            KeybindsList:SetFlags(selectedFlags)
        end
    end
})

-- Мультибокс для выбора отображаемых кейбиндов
KeybindsSection:List({
    Name = "Show Keybinds",
    Options = KeybindNames,
    Default = {KeybindNames[1]}, -- По умолчанию выбираем первый кейбинд
    Max = #KeybindNames,
    Flag = "KeybindsListFlags",
    Callback = function(selected)
        -- Преобразуем выбранные имена в флаги
        local selectedFlags = {}
        for i, name in ipairs(KeybindNames) do
            if table.find(selected, name) then
                table.insert(selectedFlags, KeybindFlags[i])
            end
        end
        KeybindsList:SetFlags(selectedFlags)
    end
})

-- Create a notification to show the UI is loaded
Library:Notification("UI loaded successfully", 3)

-- Manually add InputBegan event for Insert key as backup toggle
game:GetService("UserInputService").InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.Insert then
        Library:SetOpen(not Library.Open)
    end
end)

-- Create Misc sections
local FeaturesSection = MiscPage:Section({
    Name = "Features",
    Side = "left"
})

-- Variable to hold the Anti AFK connection
local antiAfkConnection = nil

-- Anti AFK Toggle
FeaturesSection:Toggle({
    Name = "Anti AFK",
    Default = false,
    Flag = "AntiAFKEnabled",
    Callback = function(value)
        local VirtualUser = game:GetService("VirtualUser")
        local LocalPlayer = game:GetService("Players").LocalPlayer

        if value then -- Enable Anti AFK
            if LocalPlayer and antiAfkConnection == nil then
                antiAfkConnection = LocalPlayer.Idled:Connect(function()
                    VirtualUser:CaptureController()
                    VirtualUser:ClickButton2(Vector2.new())
                end)
            end
        else -- Disable Anti AFK
            if antiAfkConnection ~= nil then
                antiAfkConnection:Disconnect()
                antiAfkConnection = nil
            end
        end
    end
})
